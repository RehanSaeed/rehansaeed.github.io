{"hash":"651609d612348b285def7454ed09831314e87e38","data":{"tag":{"title":"Git","path":"/tag/git/","belongsTo":{"edges":[{"node":{"title":".gitattributes Best Practices","path":"/gitattributes-best-practices/","date":"22 July 2019","timeToRead":6,"description":"Best practices for configuring Git in the .gitattributes file. Configuring CRLF and LF line endings. Configuring Git Large File System (LFS) for binary files.","content":"<h2 id=\"gitignore\"><a href=\"#gitignore\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"22\" height=\"22\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>.gitignore</h2>\n<p>If you've messed with Git for long enough, you're aware that you can use the .gitignore file to exclude files from being checked into your repository. There is even a whole <a href=\"https://github.com/github/gitignore\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub repository</a> with nothing but pre-made <code class=\"language-text\">.gitignore</code> files you can download. If you work with anything vaguely in the Microsoft space with Visual Studio, you probably want the <a href=\"https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">'Visual Studio' .gitignore file</a>.</p>\n<h2 id=\"gitattributes\"><a href=\"#gitattributes\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"22\" height=\"22\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>.gitattributes</h2>\n<p>There is a lesser know <a href=\"https://www.git-scm.com/docs/gitattributes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">.gitattributes</a> file that can control a bunch of Git settings that you should consider adding to almost <strong>every</strong> repository as a matter of course.</p>\n<h3 id=\"line-endings\"><a href=\"#line-endings\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"22\" height=\"22\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line Endings</h3>\n<p>If you've studied a little computer science, you'll have seen that operating systems use different characters to represent line feeds in text files. Windows uses a Carriage Return (CR) followed by the Line Feed (LF) character, while Unix based operating systems use the Line Feed (LF) alone. All of this has it's origin in typewriters which is pretty amazing given how antiquated they are. I recommend reading the <a href=\"https://en.wikipedia.org/wiki/Newline\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Newline Wikipedia article</a> for more on the subject.</p>\n<p>Newline characters often cause problems in Git when you have developers working on different operating systems (Windows, Mac and Linux). If you've ever seen a phantom file change where there are no visible changes, that could be because the line endings in the file have been changed from CRLF to LF or vice versa.</p>\n<p>Git can actually be configured to automatically handle line endings using a setting called <a href=\"https://help.github.com/en/articles/configuring-git-to-handle-line-endings\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">autocrlf</a>. This automatically changes the line endings in files depending on the operating system. However, you shouldn't rely on people having correctly configured Git installations. If someone with an incorrect configuration checked in a file, it would not be easily visible in a pull request and you'd end up with a repository with inconsistent line endings.</p>\n<p>The solution to this is to add a <code class=\"language-text\">.gitattributes</code> file at the root of your repository and set the line endings to be automatically normalised like so:</p>\n<div class=\"line-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\"><span class=\"token comment\"># Set default behaviour to automatically normalize line endings.</span>\n* text=auto\n\n<span class=\"token comment\"># Force bash scripts to always use lf line endings so that if a repo is accessed</span>\n<span class=\"token comment\"># in Unix via a file share from Windows, the scripts will work.</span>\n*.sh text eol=lf</code></pre></div>\n<p>The second line is not strictly necessary. It hard codes the line endings for bash scripts to be LF, so that they can be executed via a file share. It's a practice I picked up from the <a href=\"https://github.com/dotnet/corefx/blob/master/.gitattributes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">corefx repository</a>.</p>\n<h3 id=\"git-large-file-system-lfs\"><a href=\"#git-large-file-system-lfs\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"22\" height=\"22\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Git Large File System (LFS)</h3>\n<p>It's pretty common to want to checking binary files into your Git repository. Building a website for example, involves images, fonts, maybe some compressed archives too. The problem with these binary files is that they bloat the repository a fair bit. Every time you check-in a change to a binary file, you've now got both files saved in Git's history. Over time this bloats the repository and makes cloning it slow. A much better solution is to use <a href=\"https://git-lfs.github.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Git Large File System (LFS)</a>. LFS stores binary files in a separate file system. When you clone a repository, you only download the latest copies of the binary files and not every single changed version of them.</p>\n<p>LFS is supported by most source control providers like GitHub, Bitbucket and Azure DevOps. It a plugin to Git that has to be separately installed (It's a checkbox in the Git installer) and it even has it's own CLI command 'git lfs' so you can run queries and operations against the files in LFS. You can control which files fall under LFS's remit in the <code class=\"language-text\">.gitattributes</code> file like so:</p>\n<div class=\"line-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\"> # Archives\n*.7z filter=lfs diff=lfs merge=lfs -text\n*.br filter=lfs diff=lfs merge=lfs -text\n*.gz filter=lfs diff=lfs merge=lfs -text\n*.tar filter=lfs diff=lfs merge=lfs -text\n*.zip filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Documents</span>\n*.pdf filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Images</span>\n*.gif filter=lfs diff=lfs merge=lfs -text\n*.ico filter=lfs diff=lfs merge=lfs -text\n*.jpg filter=lfs diff=lfs merge=lfs -text\n*.pdf filter=lfs diff=lfs merge=lfs -text\n*.png filter=lfs diff=lfs merge=lfs -text\n*.psd filter=lfs diff=lfs merge=lfs -text\n*.webp filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Fonts</span>\n*.woff2 filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Other</span>\n*.exe filter=lfs diff=lfs merge=lfs -text </code></pre></div>\n<p>So here I've added a whole list of file extensions for various file types I want to be controlled by Git LFS. I tell Git that I want to filter, diff and merge using the LFS tool and finally the <code class=\"language-text\">-text</code> argument tells Git that this is not a text file, which is a strange way to tell it that it's a binary file.</p>\n<p>A quick warning about adding LFS to an existing repository with existing binary files checked into it. The existing binary files will be checked into Git and not LFS without rewriting Git history which would be bad and you shouldn't do unless you are the only developer. You will have to add a one off commit to take the latest versions of all binary files and add them to LFS. Everyone who uses the repository will also have to re-clone the repository (I found this out the hard way in a team of 15 people. Many apologies were made over the course of a week). Ideally you add this from day one and educate developers about Git's treatment of binary files, so people don't check-in any binary files not controlled by LFS.</p>\n<h3 id=\"binary-files\"><a href=\"#binary-files\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"22\" height=\"22\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary Files</h3>\n<p>When talking about the <code class=\"language-text\">.gitattributes</code> file, you will quite often hear some people talk about explicitly listing all binary files instead of relying on Git to auto-detect binary files (yes Git is clever enough to do that) like this:</p>\n<div class=\"line-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\"><span class=\"token comment\"># Denote all files that are truly binary and should not be modified.</span>\n*.png binary\n*.jpg binary</code></pre></div>\n<p>As you saw above, we already do this with Git LFS but if you don't use LFS, read on as you may need to explicitly list binary files in certain rare circumstances.</p>\n<p>I was interested so I asked a <a href=\"https://stackoverflow.com/questions/57030698/do-i-really-need-to-specify-all-binary-files-in-gitattributes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">StackOverflow question</a> and got great answers. If you look at the <a href=\"https://github.com/git/git/blob/9c9b961d7eb15fb583a2a812088713a68a85f1c0/xdiff-interface.c#L187-L193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Git source code</a>, it checks first 8,000 bytes of a file to see if it contains a NUL character. If it does, the file is assumed to be binary. However, there are cases where you may need to do it explicitly:</p>\n<ul>\n<li>UTF-16 encoded files could be mis-detected as binary.</li>\n<li>Some image format or file that consists only of printable ASCII bytes. This is pretty weird and sounds unlikely to happen.</li>\n</ul>\n<h2 id=\"final-form\"><a href=\"#final-form\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"22\" height=\"22\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Final Form</h2>\n<p>This is what the final <code class=\"language-text\">.gitattributes</code> file I copy to most repositories looks like:</p>\n<div class=\"line-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\"><span class=\"token comment\">###############################</span>\n<span class=\"token comment\"># Git Line Endings            #</span>\n<span class=\"token comment\">###############################</span>\n\n<span class=\"token comment\"># Set default behaviour to automatically normalize line endings.</span>\n* text=auto\n\n<span class=\"token comment\"># Force bash scripts to always use lf line endings so that if a repo is accessed</span>\n<span class=\"token comment\"># in Unix via a file share from Windows, the scripts will work.</span>\n*.sh text eol=lf\n\n<span class=\"token comment\">###############################</span>\n<span class=\"token comment\"># Git Large File System (LFS) #</span>\n<span class=\"token comment\">###############################</span>\n\n<span class=\"token comment\"># Archives</span>\n*.7z filter=lfs diff=lfs merge=lfs -text\n*.br filter=lfs diff=lfs merge=lfs -text\n*.gz filter=lfs diff=lfs merge=lfs -text\n*.tar filter=lfs diff=lfs merge=lfs -text\n*.zip filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Documents</span>\n*.pdf filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Images</span>\n*.gif filter=lfs diff=lfs merge=lfs -text\n*.ico filter=lfs diff=lfs merge=lfs -text\n*.jpg filter=lfs diff=lfs merge=lfs -text\n*.pdf filter=lfs diff=lfs merge=lfs -text\n*.png filter=lfs diff=lfs merge=lfs -text\n*.psd filter=lfs diff=lfs merge=lfs -text\n*.webp filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Fonts</span>\n*.woff2 filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Other</span>\n*.exe filter=lfs diff=lfs merge=lfs -text</code></pre></div>\n<h2 id=\"conclusions\"><a href=\"#conclusions\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"22\" height=\"22\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusions</h2>\n<p>All of the above are bits and pieces I've put together over time. Are there any other settings that should be considered best practice and added to any <code class=\"language-text\">.gitattributes</code> file?</p>\n"}},{"node":{"title":"Git Cloning the Windows OS Repo","path":"/git-cloning-the-windows-os-repo/","date":"24 June 2019","timeToRead":4,"description":"My experiences of cloning and working on the Windows OS Git repository.","content":"<div class=\"custom-block warning\"><p class=\"custom-block-title\">Disclaimer</p><p>I'm a Microsoft employee but my opinions in this personal blog post are my own and nothing to do with Microsoft. The information in this blog post is already publicly available and I talk in very general terms.</p></div>\n<p>I recently had the unique opportunity to git clone the Windows OS repository. For me as a developer, I think that has got to be a bucket list (a list of things to do before you die) level achievement!</p>\n<p>A colleague who was doing some work in the repo was on leave and the task of completing the job unexpectedly fell on me to finish up. I asked around to see if anyone had any pointers on what to do and I was pointed towards an Azure DevOps project. The first thing I naively tried was running:</p>\n<div class=\"line-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\">git clone https:<span class=\"token operator\">/</span><span class=\"token operator\">/</span>microsoft<span class=\"token punctuation\">.</span>fake<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>foo<span class=\"token operator\">/</span>bar<span class=\"token operator\">/</span>os</code></pre></div>\n<p>This gave me the very helpful error:</p>\n<div class=\"line-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">remote: This repo requires GVFS. Ensure the version of git you are using supports GVFS.\nfatal: protocol error: bad pack header</code></pre></div>\n<p>This triggered a memory in the dark recesses of my mind about <a href=\"https://devblogs.microsoft.com/devops/announcing-gvfs-git-virtual-file-system/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GVFS (Git Virtual File System)</a>. The Windows OS repository is around 250GB in size. When you consider that there are tens or maybe hundreds of developers committing changes every day, you are not going to have a very pleasant developer experiences if you just used Git and tried to pull all 250GB of files. So GVFS abstracts away the file system and only downloads files when you try to access them.</p>\n<p>The Windows OS has a very large and thorough internal Wiki. This wiki has sections covering all areas of the Windows OS going back for years. After a short time searching the wiki I discovered a very thorough getting started guide for new developers.</p>\n<p>The getting started guide involves running some PowerShell files which install a very specific but recent version of Git and setting up GVFS. Interestingly, you can also optionally point your Git client at a cache server to speed up git commands. There are a few cache servers all over the world to choose from. Finally, there is a VS Code extension specific to the OS repo that gives you some extra intelli-sense, very fancy.</p>\n<p>Even though pulling the code using GVFS should in theory only pull what you need at any given time, it still took a fair amount of time to get started. Standard git commands still worked but took tens of seconds to execute, so you had to be pretty sure of what you were doing.</p>\n<p>At this point a colleague warned against using 'find in files', as this would cause GVFS to pull all files to disk. I think search would do the same. An alternative approach I used instead was to search via the Azure DevOps website where you can view all files in any repo.</p>\n<p>Once I'd had a chance to have a root around the repo, I realised that it was probably the largest folder structure I'd ever seen. There are many obscure sounding folders like 'ds' and 'net'. The reason for the wiki's existence became clear.</p>\n<p>Other random things I found was that the repo contains an 'src' folder just like a lot of other repositories. There is a tonne of file extensions I've never seen or heard of before and there are binaries checked into the repo which seems suboptimal on the face of it. I even found the <code class=\"language-text\">Newtonsoft.Json</code> binary in there.</p>\n<p>I was pleasantly surprised to see an <code class=\"language-text\">.editorconfig</code> file in the repo. It turns out that spaces are preferred over tabs and line endings are CRLF (I don't know what else I expected).</p>\n<p>There is a tools folder with dozens of tools in it. In fact, I had to use one of these tools to get my job done. The tool I used was a package manager a bit like NuGet. You can use a CLI tool to version and upload a folder of files. This made sense. The OS repo does not a mono repo in that it doesn't contain every line of code in Windows. There are many other repositories that package up and upload their binaries using this tool.</p>\n<p>Some further reading on this package manager and I discovered that the Windows OS does some de-duplication of files to save space. I'm guessing they still have to fit Windows onto a DVD (How quaint, do people still use DVD's?), so file size is important.</p>\n<p>While trying to figure out how to use the package manager, I accidentally executed a search through all packages. Text came streaming down the page like in the Matrix. Eventually I managed to fumble the right keys on the keyboard to cancel the search.</p>\n<p>Once I'd finished with my changes I checked in and found that I had to rebase because newer commits were found on the server. I re-based as normal, except for the very long delay in executing git commands.</p>\n<p>Once I'd finally pushed the branch containing my changes up to the server, I created a pull request in Azure DevOps. As soon as I'd done that, I got inundated with emails from Azure Pipelines telling me that a build had started and various reviewers had been added to my pull request.</p>\n<p>The Azure Pipelines build only took 25 minutes to complete. A quick look shows a bunch of builds with five hours or more. I'm guessing that my changes had only gone through a cursory initial build to make sure nothing was completely broken.</p>\n<p>A few days later I got a notification telling me my pull request had been merged. All I did was change a few config files and upload a package or two, but it was an interesting experience none the less.</p>\n"}}]}}},"context":{}}