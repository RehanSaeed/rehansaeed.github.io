{"hash":"5b5c9901b91b359d72de3bc5cf745eb26b300f4d","data":{"tag":{"title":"async await","path":"/tag/async-await/","belongsTo":{"edges":[{"node":{"title":"Reactive Extensions (Rx) – Part 5 – Awaiting Observables","path":"/reactive-extensions-part5-awaiting-observables/","date":"27 March 2014","timeToRead":5,"description":"How and where to use Task Parallel Library (TPL) async and await with Reactive Extensions (Rx). Also, how to use TPL for awaiting observables.","content":"<ul>\n<li><a href=\"/reactive-extensions-part1-replacing-events/\">Reactive Extensions (Rx) - Part 1 - Replacing C# Events</a></li>\n<li><a href=\"/reactive-extensions-part2-wrapping-events/\">Reactive Extensions (Rx) - Part 2 - Wrapping C# Events</a></li>\n<li><a href=\"/reactive-extensions-part3-naming-conventions/\">Reactive Extensions (Rx) - Part 3 - Naming Conventions</a></li>\n<li><a href=\"/reactive-extensions-part4-replacing-timers/\">Reactive Extensions (Rx) - Part 4 - Replacing Timers</a></li>\n<li><a href=\"/reactive-extensions-part4-awaiting-observables/\">Reactive Extensions (Rx) - Part 5 - Awaiting Observables</a></li>\n<li><a href=\"/reactive-extensions-part6-task-toobservable/\">Reactive Extensions (Rx) - Part 6 - Task ToObservable</a></li>\n<li><a href=\"/reactive-extensions-part7-sample-events/\">Reactive Extensions (Rx) - Part 7 - Sample Events</a></li>\n<li><a href=\"/reactive-extensions-rx-part-8-timeouts/\">Reactive Extensions (Rx) - Part 8 - Timeouts</a></li>\n</ul>\n<p>So I've just finished extolling the wonderful virtues of <code class=\"language-text\">TaskCompletionSource</code> with a colleague and thought I'd share the joy more widely. Eventually this will turn into a post about how great Reactive Extensions (Rx) is, I promise.</p>\n<h1 id=\"taskcompletionsource\"><a href=\"#taskcompletionsource\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TaskCompletionSource</h1>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/dd449174%28v=vs.110%29.aspx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TaskCompletionSource</a> is a great tool to turn any asynchronous operation which does not follow the Task Parallel Library (TPL) pattern into a Task. The example below is something I've started to do in a few places.</p>\n<div class=\"line-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\"><span class=\"token keyword\">public</span> Task<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">?</span><span class=\"token operator\">></span> <span class=\"token function\">ShowDialog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    TaskCompletionSource<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">?</span><span class=\"token operator\">></span> taskCompletionSource <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token generic-method\"><span class=\"token function\">TaskCompletionSource</span><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">bool</span>?<span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Window</span> window <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyDialogWindow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">EventHandler</span> eventHandler <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    eventHandler <span class=\"token operator\">=</span> \n        <span class=\"token punctuation\">(</span>sender<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n        <span class=\"token punctuation\">{</span>\n            window<span class=\"token punctuation\">.</span>Closed <span class=\"token operator\">-=</span> eventHandler<span class=\"token punctuation\">;</span>\n            taskCompletionSource<span class=\"token punctuation\">.</span><span class=\"token function\">SetResult</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>DialogResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    window<span class=\"token punctuation\">.</span>Closed <span class=\"token operator\">+=</span> eventHandler<span class=\"token punctuation\">;</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">Show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> taskCompletionSource<span class=\"token punctuation\">.</span>Task<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In the example above we are creating a new window, registering for its <code class=\"language-text\">Closed</code> event and then showing the window. When the window is closed, we de-register from the closed event handler (To avoid a remaining reference to the window, causing a memory leak) and the <code class=\"language-text\">DialogResult</code> of the window is passed to the <code class=\"language-text\">TaskCompletionSource</code> using the <code class=\"language-text\">SetResult</code> method.</p>\n<p>The <code class=\"language-text\">TaskCompletionSource</code> gives us a nice <code class=\"language-text\">Task</code> object which we can return at the end of the method. When we return the task its status is <code class=\"language-text\">WaitingForActivation</code>. Only when the <code class=\"language-text\">SetResult</code> method is called when the window closes, does the tasks status change to <code class=\"language-text\">RanToCompletion</code>.</p>\n<p>This whole operation has been wrapped up and packaged nicely in a <code class=\"language-text\">Task&lt;bool?&gt;</code> with a nice bow on top with the help of <code class=\"language-text\">TaskCompletionSource</code>. Now we can call the method and await the results from the method call, thus allowing us to savour the power and simplicity the TPL affords us.</p>\n<div class=\"line-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\"><span class=\"token keyword\">bool</span><span class=\"token punctuation\">?</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">ShowDialog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>There are other great ways to use <code class=\"language-text\">TaskCompletionSource</code> of course. Generally speaking though I have found myself using it to turn an operation where I am waiting for an event into a task. For <a href=\"http://blogs.msdn.com/b/pfxteam/archive/2009/06/02/9685804.aspx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">more information</a> on <code class=\"language-text\">TaskCompletionSource</code> or the TPL in general I highly recommend reading <a href=\"http://blogs.msdn.com/b/pfxteam/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Stephen Toub's blog</a>.</p>\n<h1 id=\"awaiting-observables\"><a href=\"#awaiting-observables\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Awaiting Observables</h1>\n<p>Having showed my colleague the above example and feeling very content, I suddenly realised that Reactive Extensions (Rx) can make the code even simpler. With the advent of the latest version of Reactive Extensions (Rx) you can now await observables and we can turn the method above into this:</p>\n<div class=\"line-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> Task<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">?</span><span class=\"token operator\">></span> <span class=\"token function\">ShowDialog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> window <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyDialogWindow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> closed <span class=\"token operator\">=</span> Observable\n        <span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">FromEventPattern</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">EventHandler</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">EventArgs</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>\n            h <span class=\"token operator\">=></span> window<span class=\"token punctuation\">.</span>Closed <span class=\"token operator\">+=</span> h<span class=\"token punctuation\">,</span>\n            h <span class=\"token operator\">=></span> window<span class=\"token punctuation\">.</span>Closed <span class=\"token operator\">-=</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">Show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">await</span> closed<span class=\"token punctuation\">.</span><span class=\"token function\">FirstAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> window<span class=\"token punctuation\">.</span>DialogResult<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">await</code> keyword is just some syntactic sugar in the C# language that makes writing thorny asynchronous code effortless. The real meat of what drives it is the <code class=\"language-text\">GetAwaiter</code> method. The Reactive Extensions (Rx) team seeing the genius that is the Task Parallel Library (TPL) took advantage. They added this method (actually an extension method) to <code class=\"language-text\">IObservable&lt;T&gt;</code>, allowing us to await an observable as seen in the example above.</p>\n<p>However, there is a caveat which I shall explain. In the example above the Closed event could conceivably be fired any number of times (If the window was opened and closed a few times) and the observable wrapper around the Closed event never completes. So our observable returns multiple results but a task can only return a single result.</p>\n<p>The secret in our example is the <code class=\"language-text\">FirstAsync</code> method. We are actually awaiting the first result returned by our observable and don't care about any further results. By default awaiting an observable without the <code class=\"language-text\">FirstAsync</code> method above will actually await the last result <strong>before completion</strong>. If your observable does not complete, then you will be waiting <strong>forever</strong>!</p>\n<p>Handily the Reactive Extensions (Rx) team has added several methods which you can use before you use <code class=\"language-text\">await</code> to modify the result of what you are awaiting. All of these methods end with the word <code class=\"language-text\">Async</code>. I've added a short list of these methods below (There are lots of overloads so I've just highlighted the main ones):</p>\n<div class=\"line-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\"><span class=\"token comment\">// Returns the first element of an observable sequence.</span>\n<span class=\"token keyword\">string</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">FirstAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Returns the first element of an observable sequence, or a default value if no such element exists.</span>\n<span class=\"token keyword\">string</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">FirstOrDefaultAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Returns the last element of an observable sequence. </span>\n<span class=\"token comment\">// This is the default action of awaiting an observable.</span>\n<span class=\"token keyword\">string</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">LastAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Returns the last element of an observable sequence, </span>\n<span class=\"token comment\">// or a default value if no such element exists.</span>\n<span class=\"token keyword\">string</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">LastOrDefaultAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Returns the only element of an observable sequence, and throws an exception if there is not exactly </span>\n<span class=\"token comment\">// one element in the observable sequence.</span>\n<span class=\"token keyword\">string</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">SingleAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Returns the only element of an observable sequence, or a default value if the observable sequence </span>\n<span class=\"token comment\">// is empty; this method reports an exception if there is more than one element in the observable sequence.</span>\n<span class=\"token keyword\">string</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">SingleOrDefaultAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Invokes an action for each element in the observable sequence and returns a Task that will get </span>\n<span class=\"token comment\">// signalled when the sequence terminates.</span>\n<span class=\"token keyword\">await</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">ForEachAsync</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>All of the above methods allow you to pick a single result from your observable. <code class=\"language-text\">ForEachAsync</code> is different though as it performs an action on each item and when your observable completes (If it does) then the task completes.</p>\n<h1 id=\"conclusions\"><a href=\"#conclusions\" aria-hidden=\"true\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"aria-hidden\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusions</h1>\n<p>So we've learned how to await observables in different ways and how it can be another way of doing the same thing that <code class=\"language-text\">TaskCompletionSource</code> does but in a cleaner more elegant way.</p>\n<p>We've also learned that there are some caveats that you need to be aware of when awaiting an observable i.e. that observables return multiple results and you have to pick one to return in your task.</p>\n"}}]}}},"context":{}}