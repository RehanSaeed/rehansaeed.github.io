{"hash":"96942fcc34ee7c6be3a4ba43474220c306cc5017","data":{"post":{"title":".gitattributes Best Practices","path":"/gitattributes-best-practices/","date":"22 July 2019","timeToRead":6,"tags":[{"id":"Git","title":"Git","path":"/tag/git/"},{"id":"Git LFS","title":"Git LFS","path":"/tag/git-lfs/"},{"id":"gitattributes","title":"gitattributes","path":"/tag/gitattributes/"},{"id":"GitHub","title":"GitHub","path":"/tag/git-hub/"},{"id":"gitignore","title":"gitignore","path":"/tag/gitignore/"}],"description":"Best practices for configuring Git in the .gitattributes file. Configuring CRLF and LF line endings. Configuring Git Large File System (LFS) for binary files.","content":"<h2 id=\"gitignore\"><a href=\"#gitignore\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>.gitignore</h2>\n<p>If you've messed with Git for long enough, you're aware that you can use the .gitignore file to exclude files from being checked into your repository. There is even a whole <a href=\"https://github.com/github/gitignore\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub repository</a> with nothing but pre-made <code class=\"language-text\">.gitignore</code> files you can download. If you work with anything vaguely in the Microsoft space with Visual Studio, you probably want the <a href=\"https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">'Visual Studio' .gitignore file</a>.</p>\n<h2 id=\"gitattributes\"><a href=\"#gitattributes\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>.gitattributes</h2>\n<p>There is a lesser know <a href=\"https://www.git-scm.com/docs/gitattributes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">.gitattributes</a> file that can control a bunch of Git settings that you should consider adding to almost <strong>every</strong> repository as a matter of course.</p>\n<h3 id=\"line-endings\"><a href=\"#line-endings\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Line Endings</h3>\n<p>If you've studied a little computer science, you'll have seen that operating systems use different characters to represent line feeds in text files. Windows uses a Carriage Return (CR) followed by the Line Feed (LF) character, while Unix based operating systems use the Line Feed (LF) alone. All of this has it's origin in typewriters which is pretty amazing given how antiquated they are. I recommend reading the <a href=\"https://en.wikipedia.org/wiki/Newline\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Newline Wikipedia article</a> for more on the subject.</p>\n<p>Newline characters often cause problems in Git when you have developers working on different operating systems (Windows, Mac and Linux). If you've ever seen a phantom file change where there are no visible changes, that could be because the line endings in the file have been changed from CRLF to LF or vice versa.</p>\n<p>Git can actually be configured to automatically handle line endings using a setting called <a href=\"https://help.github.com/en/articles/configuring-git-to-handle-line-endings\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">autocrlf</a>. This automatically changes the line endings in files depending on the operating system. However, you shouldn't rely on people having correctly configured Git installations. If someone with an incorrect configuration checked in a file, it would not be easily visible in a PR and you'd end up with a repository with inconsistent line endings.</p>\n<p>The solution to this is to add a <code class=\"language-text\">.gitattributes</code> file at the root of your repository and set the line endings to be automatically normalised like so:</p>\n<div class=\"line-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\"><span class=\"token comment\"># Set default behaviour to automatically normalize line endings.</span>\n* text=auto\n\n<span class=\"token comment\"># Force bash scripts to always use lf line endings so that if a repo is accessed</span>\n<span class=\"token comment\"># in Unix via a file share from Windows, the scripts will work.</span>\n*.sh text eol=lf</code></pre></div>\n<p>The second line is not strictly necessary. It hard codes the line endings for bash scripts to be LF, so that they can be executed via a file share. It's a practice I picked up from the <a href=\"https://github.com/dotnet/corefx/blob/master/.gitattributes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">corefx repository</a>.</p>\n<h3 id=\"git-large-file-system-lfs\"><a href=\"#git-large-file-system-lfs\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Git Large File System (LFS)</h3>\n<p>It's pretty common to want to checking binary files into your Git repository. Building a website for example, involves images, fonts, maybe some compressed archives too. The problem with these binary files is that they bloat the repository a fair bit. Every time you check-in a change to a binary file, you've now got both files saved in Git's history. Over time this bloats the repository and makes cloning it slow. A much better solution is to use <a href=\"https://git-lfs.github.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Git Large File System (LFS)</a>. LFS stores binary files in a separate file system. When you clone a repository, you only download the latest copies of the binary files and not every single changed version of them.</p>\n<p>LFS is supported by most source control providers like GitHub, Bitbucket and Azure DevOps. It a plugin to Git that has to be separately installed (It's a checkbox in the Git installer) and it even has it's own CLI command 'git lfs' so you can run queries and operations against the files in LFS. You can control which files fall under LFS's remit in the <code class=\"language-text\">.gitattributes</code> file like so:</p>\n<div class=\"line-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\"> # Archives\n*.7z filter=lfs diff=lfs merge=lfs -text\n*.br filter=lfs diff=lfs merge=lfs -text\n*.gz filter=lfs diff=lfs merge=lfs -text\n*.tar filter=lfs diff=lfs merge=lfs -text\n*.zip filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Documents</span>\n*.pdf filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Images</span>\n*.gif filter=lfs diff=lfs merge=lfs -text\n*.ico filter=lfs diff=lfs merge=lfs -text\n*.jpg filter=lfs diff=lfs merge=lfs -text\n*.pdf filter=lfs diff=lfs merge=lfs -text\n*.png filter=lfs diff=lfs merge=lfs -text\n*.psd filter=lfs diff=lfs merge=lfs -text\n*.webp filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Fonts</span>\n*.woff2 filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Other</span>\n*.exe filter=lfs diff=lfs merge=lfs -text </code></pre></div>\n<p>So here I've added a whole list of file extensions for various file types I want to be controlled by Git LFS. I tell Git that I want to filter, diff and merge using the LFS tool and finally the <code class=\"language-text\">-text</code> argument tells Git that this is not a text file, which is a strange way to tell it that it's a binary file.</p>\n<p>A quick warning about adding LFS to an existing repository with existing binary files checked into it. The existing binary files will be checked into Git and not LFS without rewriting Git history which would be bad and you shouldn't do unless you are the only developer. You will have to add a one off commit to take the latest versions of all binary files and add them to LFS. Everyone who uses the repository will also have to re-clone the repository (I found this out the hard way in a team of 15 people. Many apologies were made over the course of a week). Ideally you add this from day one and educate developers about Git's treatment of binary files, so people don't check-in any binary files not controlled by LFS.</p>\n<h3 id=\"binary-files\"><a href=\"#binary-files\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Binary Files</h3>\n<p>When talking about the <code class=\"language-text\">.gitattributes</code> file, you will quite often hear some people talk about explicitly listing all binary files instead of relying on Git to auto-detect binary files (yes Git is clever enough to do that) like this:</p>\n<div class=\"line-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\"><span class=\"token comment\"># Denote all files that are truly binary and should not be modified.</span>\n*.png binary\n*.jpg binary</code></pre></div>\n<p>As you saw above, we already do this with Git LFS but if you don't use LFS, read on as you may need to explicitly list binary files in certain rare circumstances.</p>\n<p>I was interested so I asked a <a href=\"https://stackoverflow.com/questions/57030698/do-i-really-need-to-specify-all-binary-files-in-gitattributes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">StackOverflow question</a> and got great answers. If you look at the <a href=\"https://github.com/git/git/blob/9c9b961d7eb15fb583a2a812088713a68a85f1c0/xdiff-interface.c#L187-L193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Git source code</a>, it checks first 8,000 bytes of a file to see if it contains a NUL character. If it does, the file is assumed to be binary. However, there are cases where you may need to do it explicitly:</p>\n<ul>\n<li>UTF-16 encoded files could be mis-detected as binary.</li>\n<li>Some image format or file that consists only of printable ASCII bytes. This is pretty weird and sounds unlikely to happen.</li>\n</ul>\n<h2 id=\"final-form\"><a href=\"#final-form\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Final Form</h2>\n<p>This is what the final <code class=\"language-text\">.gitattributes</code> file I copy to most repositories looks like:</p>\n<div class=\"line-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\"><span class=\"token comment\">###############################</span>\n<span class=\"token comment\"># Git Line Endings            #</span>\n<span class=\"token comment\">###############################</span>\n\n<span class=\"token comment\"># Set default behaviour to automatically normalize line endings.</span>\n* text=auto\n\n<span class=\"token comment\"># Force bash scripts to always use lf line endings so that if a repo is accessed</span>\n<span class=\"token comment\"># in Unix via a file share from Windows, the scripts will work.</span>\n*.sh text eol=lf\n\n<span class=\"token comment\">###############################</span>\n<span class=\"token comment\"># Git Large File System (LFS) #</span>\n<span class=\"token comment\">###############################</span>\n\n<span class=\"token comment\"># Archives</span>\n*.7z filter=lfs diff=lfs merge=lfs -text\n*.br filter=lfs diff=lfs merge=lfs -text\n*.gz filter=lfs diff=lfs merge=lfs -text\n*.tar filter=lfs diff=lfs merge=lfs -text\n*.zip filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Documents</span>\n*.pdf filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Images</span>\n*.gif filter=lfs diff=lfs merge=lfs -text\n*.ico filter=lfs diff=lfs merge=lfs -text\n*.jpg filter=lfs diff=lfs merge=lfs -text\n*.pdf filter=lfs diff=lfs merge=lfs -text\n*.png filter=lfs diff=lfs merge=lfs -text\n*.psd filter=lfs diff=lfs merge=lfs -text\n*.webp filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Fonts</span>\n*.woff2 filter=lfs diff=lfs merge=lfs -text\n\n<span class=\"token comment\"># Other</span>\n*.exe filter=lfs diff=lfs merge=lfs -text</code></pre></div>\n<h2 id=\"conclusions\"><a href=\"#conclusions\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Conclusions</h2>\n<p>All of the above are bits and pieces I've put together over time. Are there any other settings that should be considered best practice and added to any <code class=\"language-text\">.gitattributes</code> file?</p>\n","cover_image":"/images/hero/Git-1366x768.png"}},"context":{}}