{"hash":"a20d3f4f3beeaef1c11f37e9903bfc31a54c074d","data":{"post":{"title":"Model-View-ViewModel (MVVM) - Part 1 - Overview","path":"/model-view-viewmodel-mvvm-part1-overview/","displayDate":"14 May 2014","date":"2014-05-14T00:00:00+00:00","timeToRead":5,"author":"Muhammad Rehan Saeed","headings":[{"value":"Platforms"},{"value":"MVVM 'Bits'"},{"value":"Existing Frameworks"},{"value":"Conclusions"}],"tags":[{"id":".NET","title":".NET","path":"/tag/net/"},{"id":"Base Class Library","title":"Base Class Library","path":"/tag/base-class-library/"},{"id":"BCL","title":"BCL","path":"/tag/bcl/"},{"id":"C#","title":"C#","path":"/tag/c/"},{"id":"Design Patterns","title":"Design Patterns","path":"/tag/design-patterns/"},{"id":"IEditableObject","title":"IEditableObject","path":"/tag/i-editable-object/"},{"id":"INotifyDataErrorInfo","title":"INotifyDataErrorInfo","path":"/tag/i-notify-data-error-info/"},{"id":"INotifyPropertyChanged","title":"INotifyPropertyChanged","path":"/tag/i-notify-property-changed/"},{"id":"Model-View-ViewModel (MVVM)","title":"Model-View-ViewModel (MVVM)","path":"/tag/model-view-view-model-mvvm/"},{"id":"MVVM","title":"MVVM","path":"/tag/mvvm/"}],"description":"What really goes into using Model-View-ViewModel (MVVM) in .NET. Base classes for INotifyPropertyChanged, INotifyDataErrorInfo, IDisposable and a lot more.","content":"<ul>\n<li><a href=\"/model-view-viewmodel-mvvm-part1-overview/\">Model-View-ViewModel (MVVM) - Part 1 - Overview</a></li>\n<li><a href=\"/model-view-viewmodel-mvvm-part2-idisposable/\">Model-View-ViewModel (MVVM) - Part 2 - IDisposable</a></li>\n<li><a href=\"/model-view-viewmodel-mvvm-part3-inotifypropertychanged/\">Model-View-ViewModel (MVVM) - Part 3 - INotifyPropertyChanged</a></li>\n<li><a href=\"/model-view-viewmodel-mvvm-part4-inotifydataerrorinfo/\">Model-View-ViewModel (MVVM) - Part 4 - INotifyDataErrorInfo</a></li>\n</ul>\n<p>I've been meaning for some time to do a series of posts about Model-View-ViewModel (MVVM) and its potential base classes. Then I read <a href=\"http://mtaulty.com/CommunityServer/blogs/mike_taultys_blog/archive/2014/05/09/windows-phone-8-1-and-xaml-apps-making-it-easier-for-mvvm-developers.aspx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mike Taulty's post</a> about why MVVM 'bits' not built in to .NET.</p>\n<p>My aim in these posts will be to either, pick off the shelf components which are best of breed where there is no point reinventing the wheel or build my own components where necessary.</p>\n<p>Assuming you already know about the basic Model-View-ViewModel (MVVM) pattern described in the title image of this post, when we talk about MVVM, what do we really mean?</p>\n<h1 id=\"platforms\"><a href=\"#platforms\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Platforms</h1>\n<p>Well there are several .NET platforms that all provide some basic low level support for Model-View-ViewModel (MVVM), Windows Store, Windows Phone, Silverlight and Windows Presentation Foundation (WPF). It is all of these platforms that I'll be discussing and targeting my code towards.</p>\n<h1 id=\"mvvm-bits\"><a href=\"#mvvm-bits\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MVVM 'Bits'</h1>\n<p>In Mike Taulty's post, he goes through a list of 'bits' which all come together to help with building an application that fits into the MVVM design pattern. I've added to that list below:</p>\n<ol>\n<li><code class=\"language-text\">IDisposable</code> - When you have a scarce resource like a GPS, gyroscope or compass, you inevitably need to dispose of it somewhere. Implementing <code class=\"language-text\">IDisposable</code> <strong>properly</strong> is <a href=\"http://msdn.microsoft.com/en-us/library/system.idisposable%28v=vs.110%29.aspx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hard work</a>. A base class would be handy.</li>\n<li><code class=\"language-text\">INotifyPropertyChanged</code> - This is the building block of all .NET based MVVM. There needs to be a base class for this that is high performance and yet simple and easy to use.</li>\n<li><code class=\"language-text\">INotifyDataErrorInfo</code> - Validation is an often overlooked part of an application. This handy interface makes doing validation of your view models a cinch.</li>\n<li><code class=\"language-text\">IEditableObject</code> (WPF only) - This interface helps with implementing undo and redo but is used specifically in the WPF data grid.</li>\n<li><code class=\"language-text\">ObservableCollection&lt;T&gt;</code> - This collection is a good start out of the box but why does it still not have an AddRange method? Why do we not have an <code class=\"language-text\">ObservableDictionary&lt;TKey, TValue&gt;</code> or a <code class=\"language-text\">KeyedObservableCollection&lt;TKey, TValue&gt;</code>? What if you have a collection of items implementing <code class=\"language-text\">INotifyPropertyChanged</code> and you want to know if one of those items changes, why can't the collection type help you there also?</li>\n<li><code class=\"language-text\">ICommand</code> - Most implementations out there provide a base class for <code class=\"language-text\">ICommand</code> and usually call it <code class=\"language-text\">RelayCommand</code> or <code class=\"language-text\">DelegateCommand</code>. They usually have another implementation with a generic argument <code class=\"language-text\">RelayCommand&lt;T&gt;</code> or <code class=\"language-text\">DelegateCommand&lt;T&gt;</code>. These are a quick way to add a command to your view model, where the implementation of the command is usually a method in your view model passed in as a delegate. Sometimes though, this is not enough. What if you have a largish command and want to split it off into a separate class, a base class for <code class=\"language-text\">ICommand</code> would be useful. What if you have a command that does <code class=\"language-text\">async</code> and <code class=\"language-text\">await</code>? <code class=\"language-text\">ICommand</code> doesn't support that but can we provide some help here?</li>\n<li>Inversion of control (IoC) - There are a lot of IoC frameworks out there already, why reinvent the wheel. Just pick one but which one?</li>\n</ol>\n<p>I'll pause just here as I think the above listed items are all base classes that could be used across the board on all the major platforms. They are at the very heart of MVVM in .NET. The rest of the list below are more dependant on the type of application you are building.</p>\n<ol>\n<li>Navigation - This has always been a stone in my shoe. Navigation is inherently something that happens in the view but it is something that view models often need to understand. The problem is, that the view model is not supposed to know about the view at all. This problem occurs again and again in different forms on each platform.</li>\n</ol>\n<blockquote>\n<ul>\n<li>Navigating pages in Windows Store, Windows Phone, Silverlight.</li>\n<li>Navigating Windows in Windows Presentation Foundation (WPF) and Windows Store.</li>\n</ul>\n</blockquote>\n<ol>\n<li>User Interaction - I'm talking about <code class=\"language-text\">MessageBox</code>'s, <code class=\"language-text\">MessageDialog</code>'s, Toast's etc. Giving the user information or asking them questions happens on all platforms. This problem is very similar to the Navigation problem.</li>\n<li>Connecting your Views to ViewModels - This is usually some by-product of which IoC container you choose to use, whether it's MEF, Unity, Autofac or some other. There is no recommended way of doing this and I don't think I've ever found a 'correct' way of doing this.</li>\n<li>Saving View Model state - This usually needs to be done when the application closes or suspends due to some user interaction. A lot of frameworks simply serialize the whole View Model and save it away but is that the best way and what about doing that in a WPF application?</li>\n<li>Events - Passing events between view models is a fairly useful ability, allowing communication and passing of state.</li>\n<li>Composing Views - Some MVVM frameworks like PRISM provide support for composing different views together. Alternatively, this process usually has a connection with the type of IoC container you are using.</li>\n<li>Firing Commands - A lot of controls can't fire off <code class=\"language-text\">ICommand</code>'s in XAML because they don't provide a Command property or sometimes you want to fire a command based on some event or even a key press.</li>\n<li>Other Stuff - Reactive Extensions can help in some pretty interesting ways with MVVM. What about Portable Class Library's? Why does the MVVM on one platform need to be different from another?</li>\n</ol>\n<p>The last two things in the list are more abstract requirements for any MVVM framework.</p>\n<ol>\n<li>Testability - Writing a view model which is easy to test is hard work. Especially if you want to use <code class=\"language-text\">MessageBox</code>'s, GPS API's or other API's which make testing difficult. You don't want a <code class=\"language-text\">MessageBox</code> popping up in the middle of your test do you?</li>\n<li>Performance - Your application needs to run fast, especially if it's running on a phone. For example, a lot of MVVM frameworks use expression trees and reflection to raise property changed notifications . What impact does this have in the performance versus maintainability trade off?</li>\n</ol>\n<h1 id=\"existing-frameworks\"><a href=\"#existing-frameworks\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Existing Frameworks</h1>\n<p>Wow, that's a lot of stuff! All of this 'stuff' is related but covers a huge range of subjects. A lot of existing MVVM frameworks try to do all of this at once!</p>\n<p>In my humble opinion, because they do so much, they usually only cover some, say 70-80% of the full functionality. What business does an MVVM framework have including an IoC framework? There are lots of IoC frameworks out there that are far more powerful than anything we could write but a lot of MVVM frameworks include one too.</p>\n<h1 id=\"conclusions\"><a href=\"#conclusions\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Conclusions</h1>\n<p>So ideally what we need is something modular, that you can plug bits into but also something that covers all the bases.</p>\n<p>Whats your opinion? I've looked at a lot of frameworks MVVM Light, PRISM, etc. In my opinion, the seven top items are the most important but also the most neglected bits of MVVM. Is there some framework out there that does all this and more?</p>\n<p>I'll discuss this and a lot more in the coming posts.</p>\n","cover_image":"/images/hero/MVVM-1366x768.png"}},"context":{}}